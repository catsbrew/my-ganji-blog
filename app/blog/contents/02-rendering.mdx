---
title: 리액트 렌더링
publishedAt: 2025-10-09
summary: 리액트 렌더링에 대해서 알아보쟈 👀
image: /react.png
---

# ⚛️ 리액트 렌더링 원리: 앱 구동의 생명 주기

리액트 애플리케이션이 브라우저에 표시되기까지의 핵심 흐름과 그 중심 원리를 단계별로 분석합니다.

## 1\. 🚀 앱의 시작점: `index.tsx`와 DOM 마운트

리액트 애플리케이션의 구동은 \*\*진입점(`index.tsx`)\*\*에서 시작되며, 여기서 리액트가 **실제 HTML**과 연결됩니다.

```tsx
// index.tsx: 리액트 앱과 HTML DOM을 연결하는 코드

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

const entryPoint: HTMLElement | null = document.getElementById('root')

if (entryPoint) {
  // React 18의 새로운 API: 동시성(Concurrency) 기능 지원
  const root = ReactDOM.createRoot(entryPoint)
  // 최상위 <App /> 컴포넌트를 DOM에 렌더링 시작
  root.render(<App />)
}
```

### 🔑 핵심 원리

  * **연결점:** `document.getElementById('root')`는 웹 페이지에서 리액트 앱이 자리 잡을 **HTML 요소**를 정확하게 찾습니다.
  * **새로운 마운트:** `ReactDOM.createRoot()`는 **React 18**부터 도입되었으며, 향상된 성능과 동시성 기능을 제공합니다.
  * **최상위 컴포넌트:** `<App />`이 렌더링되면, 이 컴포넌트 내부의 모든 UI가 \*\*가상 DOM(Virtual DOM)\*\*에 먼저 반영됩니다.

-----

## 2\. 뼈대: `index.html`과 싱글 페이지 구조

리액트 앱은 기본적으로 **SPA (Single Page Application)** 구조를 따르며, 브라우저가 로드하는 HTML 파일은 오직 하나뿐입니다.

```html
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React App</title>
  </head>
  <body>
    <div id="root"></div> 
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
```

브라우저는 이 HTML을 로드한 후, `<div id="root">`가 비어 있는 상태에서 JavaScript를 실행하여 UI를 동적으로 채워 넣습니다.

-----

## 3\. 🧩 컴포넌트 설계 규칙과 JSX

리액트는 HTML 태그와 **사용자 정의 컴포넌트**를 명확히 구분하기 위한 규칙이 있습니다.

### 사용자 정의 컴포넌트 규칙

<table>
  <thead>
    <tr>
      <th>유형</th>
      <th>예시</th>
      <th>규칙</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>커스텀 컴포넌트</strong></td>
      <td><code>&lt;Header /&gt;</code></td>
      <td><strong>반드시 대문자로 시작</strong>해야 합니다. (PascalCase)</td>
    </tr>
    <tr>
      <td><strong>HTML 태그</strong></td>
      <td><code>&lt;div&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;h2&gt;</code></td>
      <td><strong>소문자</strong>로 시작합니다.</td>
    </tr>
  </tbody>
</table>

### JSX의 변환 과정

JSX는 브라우저가 바로 이해할 수 없습니다. 빌드 과정(Babel 등)을 거쳐 **순수한 JavaScript 함수 호출**로 변환됩니다.

<table>
  <thead>
    <tr>
      <th>JSX 코드</th>
      <th>트랜스파일 후 (JavaScript)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>&lt;h1&gt;Hello!&lt;/h1&gt;</code></td>
      <td><code>React.createElement('h1', null, 'Hello!')</code></td>
    </tr>
  </tbody>
</table>

### JSX 작성 규칙

1.  **단일 루트 요소 (Single Root Element):**
    컴포넌트에서 반환되는 모든 JSX 코드는 반드시 `<div>`나 `<section>` 또는 \*\*프래그먼트(`<>...</>`)\*\*와 같은 **하나의 부모 요소**로 감싸져야 합니다. 이는 JSX가 하나의 JavaScript 객체(트리 구조)를 반환해야 하기 때문입니다.

2.  **JavaScript 표현식:**
    JSX 마크업 내부에서 변수, 함수 호출 등 JavaScript 코드를 사용하려면 \*\*중괄호 `{}`\*\*로 감싸야 합니다.

    ```tsx
    const name: string = 'React'
    return <h1>Hello, {name}!</h1>
    ```

-----

## 4\. 🔄 렌더링 흐름 및 성능 최적화

리액트의 성능 핵심은 **가상 DOM**을 이용한 효율적인 업데이트 메커니즘에 있습니다.

### 렌더링 플로우 요약

1.  **로드:** 브라우저가 `index.html`을 읽고 `<div id="root">`를 준비합니다.
2.  **실행:** `index.tsx`의 `root.render(<App />)`가 실행됩니다.
3.  **가상 DOM:** 리액트는 `<App />` 전체 트리를 **가상 DOM**에 그립니다.
4.  **최초 반영:** 가상 DOM의 내용을 **실제 DOM의 `#root`** 안에 한 번에 반영합니다.
5.  **업데이트:** 이후 상태(State)나 속성(Props) 변경 시, 새로운 가상 DOM과 이전 가상 DOM을 비교(Diffing)하여 **변경된 부분만** 실제 DOM에 최소한으로 업데이트합니다.

-----

## 5\. 📋 핵심 정리표 (HTML Table)

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>index.tsx</strong></td>
      <td>리액트 앱의 실행 진입점이며, <code>root</code> 요소를 찾아 컴포넌트를 마운트합니다.</td>
    </tr>
    <tr>
      <td><strong>index.html</strong></td>
      <td>브라우저가 로드하는 유일한 HTML 템플릿이며, <code>id="root"</code>는 리액트 앱이 삽입될 자리입니다.</td>
    </tr>
    <tr>
      <td><strong>createRoot</strong></td>
      <td>React 18에서 도입된 API로, 앱을 마운트하며 동시성 기능을 활성화합니다.</td>
    </tr>
    <tr>
      <td><strong>커스텀 컴포넌트</strong></td>
      <td>HTML 태그와 구분하기 위해 반드시 **대문자**로 시작해야 합니다.</td>
    </tr>
    <tr>
      <td><strong>JSX 변환</strong></td>
      <td><strong>Babel</strong> 등의 트랜스파일러를 통해 <code>React.createElement</code> 함수 호출로 변환됩니다.</td>
    </tr>
    <tr>
      <td><strong>렌더링 방식</strong></td>
      <td>**가상 DOM**에서 변경 사항을 비교(Diffing)한 후, 최소한의 변경만 **실제 DOM**에 반영하여 성능을 최적화합니다.</td>
    </tr>
  </tbody>
</table>